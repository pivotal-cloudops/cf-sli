// This file was generated by counterfeiter
package cf_wrapperfakes

import (
	"errors"
	"strings"
	"sync"
	"time"

	"github.com/pivotal-cloudops/cf-sli/cf_wrapper"
)

type FakeCfWrapperInterface struct {
	RunCFStub        func(commands ...string) error
	runCFMutex       sync.RWMutex
	runCFArgsForCall []struct {
		commands []string
	}
	runCFReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCfWrapperInterface) StubFailingCF(command string) {
	fake.RunCFStub = func(commands ...string) error {
		if commands[0] == command {
			error_message := "Running CF command failed: "
			error_message += strings.Join(commands, " ")
			return errors.New(error_message)
		}
		return nil
	}
}

func (fake *FakeCfWrapperInterface) StubTimeoutCF(command string) {
	time.Sleep(5 * time.Second)
}

func (fake *FakeCfWrapperInterface) RunCF(commands ...string) error {
	fake.runCFMutex.Lock()
	fake.runCFArgsForCall = append(fake.runCFArgsForCall, struct {
		commands []string
	}{commands})
	fake.recordInvocation("RunCF", []interface{}{commands})
	fake.runCFMutex.Unlock()
	if fake.RunCFStub != nil {
		return fake.RunCFStub(commands...)
	}
	return fake.runCFReturns.result1
}

func (fake *FakeCfWrapperInterface) RunCFCallCount() int {
	fake.runCFMutex.RLock()
	defer fake.runCFMutex.RUnlock()
	return len(fake.runCFArgsForCall)
}

func (fake *FakeCfWrapperInterface) RunCFArgsForCall(i int) []string {
	fake.runCFMutex.RLock()
	defer fake.runCFMutex.RUnlock()
	return fake.runCFArgsForCall[i].commands
}

func (fake *FakeCfWrapperInterface) RunCFReturns(result1 error) {
	fake.RunCFStub = nil
	fake.runCFReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeCfWrapperInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.runCFMutex.RLock()
	defer fake.runCFMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeCfWrapperInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cf_wrapper.CfWrapperInterface = new(FakeCfWrapperInterface)
